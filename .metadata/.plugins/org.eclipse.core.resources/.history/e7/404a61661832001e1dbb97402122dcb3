/*
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.inf.languages.mockup.scoping;

import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import uk.ac.kcl.inf.languages.mockup.uiMockupLanguage.Screen
import org.eclipse.emf.ecore.EReference
import uk.ac.kcl.inf.languages.mockup.uiMockupLanguage.Entity
import uk.ac.kcl.inf.languages.mockup.uiMockupLanguage.Widget

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class UiMockupLanguageScopeProvider extends AbstractUiMockupLanguageScopeProvider {

	// Scoping rule for resolving widgets within a screen
    def IScope scope_Screen_elements(Screen screen, EReference ref) {
        // Filter out Entity elements and return scope only for Widget elements
        return Scopes.scopeFor(screen.getWidgets().filter(typeof(Widget)));
    }

    // Scoping rule for resolving attributes within an entity
    def IScope scope_Entity_attributes(Entity entity, EReference ref) {
        return Scopes.scopeFor(entity.getAttributes());
    }

    // Scoping rule for resolving fields within other widgets (TextField, Checkbox, Button)
    def IScope scope_Widget_label(Widget widget, EReference ref) {
        val screen = widget.eContainer as Screen;
        return Scopes.scopeFor(screen.getWidgets());
    }
}
